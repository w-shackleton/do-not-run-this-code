=== modified file 'src/bignum.cpp'
--- src/bignum.cpp	2012-11-24 22:25:20 +0000
+++ src/bignum.cpp	2012-11-24 22:51:37 +0000
@@ -8,16 +8,17 @@
 #define TEST_CASE(_test) if(!(_test)) cout << "Test " << #_test << " failed" << endl
 
 void mandel::bignum::testBignum() {
-	TEST_CASE(sizeof(BN<uint32_t, uint64_t, 1>) == sizeof(uint32_t));
-	TEST_CASE(sizeof(BN<uint32_t, uint64_t, 2>) == sizeof(uint32_t) * 2);
-	TEST_CASE(sizeof(BN<uint32_t, uint64_t, 4>) == sizeof(uint32_t) * 4);
-	TEST_CASE(sizeof(BN<uint32_t, uint64_t, 6>) == sizeof(uint32_t) * 6);
+	TEST_CASE(sizeof(BN<int32_t, int64_t, 1>) == sizeof(int32_t));
+	TEST_CASE(sizeof(BN<int32_t, int64_t, 2>) == sizeof(int32_t) * 2);
+	TEST_CASE(sizeof(BN<int32_t, int64_t, 4>) == sizeof(int32_t) * 4);
+	TEST_CASE(sizeof(BN<int32_t, int64_t, 6>) == sizeof(int32_t) * 6);
 
 	auto printInternalFormat = [] (long double num) {
-		cout << num << ": " << BN<uint32_t, uint64_t, 4>(num) << endl;
+		cout << num << ": " << BN<int32_t, int64_t, 4>(num) << endl;
 	};
 
 	cout << "Sizeof long double = " << sizeof(long double) << endl;
+	printInternalFormat(0);
 	printInternalFormat(4);
 	printInternalFormat(-4);
 	printInternalFormat(3.54L);

=== modified file 'src/bignum.hpp'
--- src/bignum.hpp	2012-11-24 22:25:20 +0000
+++ src/bignum.hpp	2012-11-24 22:52:41 +0000
@@ -5,6 +5,7 @@
 #define MANDEL_BIGNUM_H
 
 #include <cmath>
+#include "clUtil.h"
 #include <iostream>
 
 /* The numbers here are contained in vectors (of sort)
@@ -75,29 +76,34 @@
 			class BN : public BNVec<T, N> {
 				public:
 					typedef BNVec<T, N> P;
-					static constexpr int bitsPerValue = sizeof(T) * 8;
+					/**
+					 * The number of bits used to store number
+					 */
+					static constexpr int bitsPerValue = sizeof(T) * 8 - 1;
+					/**
+					 * A mask to extract the number parts of the number
+					 */
+					static constexpr int bitsMask = pow(2, bitsPerValue) - 1;
 					static constexpr T signBit = 1 << (sizeof(T) * 8 - 1);
-					static constexpr L maximumValue = pow(2, bitsPerValue);
+					static constexpr long double maximumValue = pow(2, bitsPerValue);
 
 					BN(long double val) {
-						P::s[0] = val;
-						val = std::abs(val);
-						for(int i = 1; i < N; i++) {
+						for(int i = 0; i < N; i++) {
+							P::s[i] = std::abs(val);
+							std::cout << "Val: " << val << std::endl;
 							val *= maximumValue;
-							P::s[i] = val;
 						}
+						hexdump(P::s, 4*4);
+						if(val < 0) -*this;
 					}
 					// To avoid accidental conversion this is a method, not an operator
 					long double toFloat() const {
 						long double result = 0;
-						int negative = P::x & signBit;
-						result += negative ? -P::x : P::x;
 						long double multiplier = 1;
-						for(int i = 1; i < N; i++) {
+						for(int i = 0; i < N; i++) {
+							result += P::s[i] * multiplier;
 							multiplier /= maximumValue;
-							result += P::s[i] * multiplier;
 						}
-						if(negative) result = -result;
 						return result;
 					}
 
@@ -105,7 +111,9 @@
 					BN() = default;
 
 					BN operator-() {
-						P::x = -P::x;
+						for(int i = 0; i < N; i++) {
+							P::s[i] = -P::s[i];
+						}
 						return *this;
 					}
 
@@ -117,7 +125,7 @@
 						L carry = 0;
 						while(i--) {
 							carry += (L)this->s[i] + (L)r.s[i];
-							dest.s[i] = carry;
+							dest.s[i] = carry & bitsMask;
 							carry >>= bitsPerValue;
 						}
 						return dest;
@@ -157,6 +165,7 @@
 				public:
 					BN operator+(BN r) {
 						BN l = *this;
+						return l.add(r);
 						int sign = 0;
 						// If either is negative, flip sign
 						// and make value positive.
@@ -181,6 +190,7 @@
 					}
 					BN operator-(BN r) {
 						BN l = *this;
+						return l.add(-r);
 						int sign = 0;
 						// If either is negative, flip sign
 						// and make value positive.
@@ -253,7 +263,7 @@
 
 		// The first number is the byte size of each element,
 		// the second is the number of elements.
-		typedef BN<uint32_t, uint64_t, 4> BN4_4;
+		typedef BN<int32_t, int64_t, 4> BN4_4;
 
 		void testBignum();
 	}

